/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/analyzer.ts":
/*!*************************!*\
  !*** ./src/analyzer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createMMDB = exports.ASTError = exports.cloneFrameContext = exports.DVRestriction = void 0;\nconst parser_1 = __webpack_require__(/*! ./parser */ \"./src/parser.ts\");\n// Represents variable disjointness restriction.\nclass DVRestriction {\n    constructor() {\n        this.pairs = new Set(); // \"a b\", \"b c\", ...\n    }\n    addPair(a, b) {\n        if (a < b) {\n            this.pairs.add(`${a} ${b}`);\n        }\n        else {\n            this.pairs.add(`${b} ${a}`);\n        }\n    }\n    add(stmt) {\n        const syms = stmt.symbols;\n        for (let i = 0; i < syms.length; i++) {\n            for (let j = i + 1; j < syms.length; j++) {\n                this.addPair(syms[i], syms[j]);\n            }\n        }\n    }\n    clone() {\n        const result = new DVRestriction();\n        result.pairs = new Set(this.pairs);\n        return result;\n    }\n    extract(requiredSyms) {\n        const result = new DVRestriction();\n        for (const pair of this.pairs) {\n            const [a, b] = pair.split(\" \");\n            if (requiredSyms.includes(a) && requiredSyms.includes(b)) {\n                result.pairs.add(pair);\n            }\n        }\n        return result;\n    }\n    substituteMultiple(subst) {\n        const result = new DVRestriction();\n        for (const pair of this.pairs) {\n            const [a, b] = pair.split(\" \");\n            const aelems = subst.get(a);\n            const belems = subst.get(b);\n            if (!aelems || !belems) {\n                throw new Error(\"Variable not found in substitution map\");\n            }\n            for (const aelem of aelems) {\n                for (const belem of belems) {\n                    if (aelem === belem) {\n                        throw new Error(`Variable ${aelem} cannot be disjoint with itself`);\n                    }\n                    result.addPair(aelem, belem);\n                }\n            }\n        }\n        return result;\n    }\n    satisfiedBy(other) {\n        for (const rel of this.pairs) {\n            if (!other.pairs.has(rel)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexports.DVRestriction = DVRestriction;\nfunction cloneFrameContext(ctx) {\n    return {\n        dvr: ctx.dvr.clone(),\n        hyps: Array.from(ctx.hyps),\n        logiHyps: Array.from(ctx.logiHyps),\n    };\n}\nexports.cloneFrameContext = cloneFrameContext;\n// Input data error at AST level.\nclass ASTError {\n    constructor(line, message) {\n        this.line = line;\n        this.message = message;\n    }\n}\nexports.ASTError = ASTError;\nfunction filterMandatoryHyps(hyps, db, logiHyps, assertionSymbols) {\n    const usedVars = new Set();\n    for (const logiHyp of logiHyps) {\n        for (const symbol of logiHyp.symbols) {\n            if (db.varSymbols.has(symbol)) {\n                usedVars.add(symbol);\n            }\n        }\n    }\n    for (const symbol of assertionSymbols) {\n        if (db.varSymbols.has(symbol)) {\n            usedVars.add(symbol);\n        }\n    }\n    return hyps.filter((hyp) => hyp.isLogi || usedVars.has(hyp.symbols[0]));\n}\nfunction parseCompressedProof(compressedProof, line) {\n    const result = [];\n    let tempNum = 0;\n    for (let i = 0; i < compressedProof.length; i++) {\n        const n = compressedProof[i].charCodeAt(0) - \"A\".charCodeAt(0);\n        if (n < 20) {\n            // A-T\n            const num = (tempNum * 20 + n);\n            tempNum = 0;\n            result.push(num);\n        }\n        else if (n < 25) {\n            // U-Y\n            tempNum = tempNum * 5 + (n - 20 + 1);\n        }\n        else if (n === 25) {\n            // Z\n            if (tempNum !== 0) {\n                throw new ASTError(line, \"Invalid compressed proof (unexpected Z)\");\n            }\n            result.push(\"Z\");\n        }\n        else {\n            throw new Error(`Unexpected character ${compressedProof[i]} in compressed proof`);\n        }\n    }\n    return result;\n}\n// throws ASTError.\nfunction createMMDB(outermostBlock) {\n    const db = {\n        constSymbols: new Set(),\n        varSymbols: new Set(),\n        extFrames: new Map(),\n    };\n    function procBlock(block, outermost, outerCtx) {\n        let currCtx = cloneFrameContext(outerCtx);\n        for (const ent of block.entries) {\n            if (ent.entryTy === parser_1.EntryType.CS) {\n                const stmt = ent.stmt;\n                if (!outermost) {\n                    throw new ASTError(stmt.declLine, \"$c can only appear in the outermost block\");\n                }\n                stmt.symbols.forEach((s) => {\n                    if (db.constSymbols.has(s) || db.varSymbols.has(s)) {\n                        throw new ASTError(stmt.declLine, `\"${s}\" is already declared and cannot be re-declared`);\n                    }\n                    db.constSymbols.add(s);\n                });\n            }\n            else if (ent.entryTy === parser_1.EntryType.VS) {\n                const stmt = ent.stmt;\n                stmt.symbols.forEach((s) => {\n                    if (db.constSymbols.has(s) || db.varSymbols.has(s)) {\n                        throw new ASTError(stmt.declLine, `\"${s}\" is already declared and cannot be re-declared`);\n                    }\n                    db.varSymbols.add(s);\n                });\n            }\n            else if (ent.entryTy === parser_1.EntryType.FS) {\n                const stmt = ent.stmt;\n                if (!db.constSymbols.has(stmt.typecode)) {\n                    throw new ASTError(stmt.declLine, `\"${stmt.typecode}\" must be a constant symbol, but it was not.`);\n                }\n                if (!db.varSymbols.has(stmt.symbol)) {\n                    throw new ASTError(stmt.declLine, `\"${stmt.symbol}\" must be a constant symbol, but it was not.`);\n                }\n                if (currCtx.hyps.some((hyp) => hyp.label === stmt.label)) {\n                    throw new ASTError(stmt.declLine, `label \"${stmt.label}\" is already declared`);\n                }\n                if (db.extFrames.has(stmt.label)) {\n                    throw new ASTError(stmt.declLine, `label \"${stmt.label}\" is already declared`);\n                }\n                currCtx.hyps.push({\n                    label: stmt.label,\n                    typecode: stmt.typecode,\n                    symbols: [stmt.symbol],\n                    isLogi: false,\n                });\n            }\n            else if (ent.entryTy === parser_1.EntryType.ES) {\n                const stmt = ent.stmt;\n                if (currCtx.hyps.some((hyp) => hyp.label === stmt.label)) {\n                    throw new ASTError(stmt.declLine, `label \"${stmt.label}\" is already declared`);\n                }\n                if (db.extFrames.has(stmt.label)) {\n                    throw new ASTError(stmt.declLine, `label \"${stmt.label}\" is already declared`);\n                }\n                currCtx.logiHyps.push(stmt);\n                currCtx.hyps.push({\n                    label: stmt.label,\n                    typecode: stmt.typecode,\n                    symbols: stmt.symbols,\n                    isLogi: true,\n                });\n            }\n            else if (ent.entryTy === parser_1.EntryType.DS) {\n                const stmt = ent.stmt;\n                currCtx.dvr.add(stmt);\n            }\n            else if (ent.entryTy === parser_1.EntryType.AS) {\n                const stmt = ent.stmt;\n                if (currCtx.hyps.some((hyp) => hyp.label === stmt.label)) {\n                    throw new ASTError(stmt.declLine, `label \"${stmt.label}\" is already declared`);\n                }\n                if (db.extFrames.has(stmt.label)) {\n                    throw new ASTError(stmt.declLine, `label \"${stmt.label}\" is already declared`);\n                }\n                db.extFrames.set(stmt.label, {\n                    context: cloneFrameContext(currCtx),\n                    assertionLabel: stmt.label,\n                    assertionLine: stmt.declLine,\n                    assertionTypecode: stmt.typecode,\n                    assertionSymbols: stmt.symbols,\n                    mandatoryDvr: currCtx.dvr.extract(stmt.symbols),\n                    mandatoryHyps: filterMandatoryHyps(currCtx.hyps, db, currCtx.logiHyps, stmt.symbols),\n                    proofLabels: null,\n                    proofCompressed: null,\n                });\n            }\n            else if (ent.entryTy === parser_1.EntryType.PS) {\n                const stmt = ent.stmt;\n                if (currCtx.hyps.some((hyp) => hyp.label === stmt.label)) {\n                    throw new ASTError(stmt.declLine, `label \"${stmt.label}\" is already declared`);\n                }\n                if (db.extFrames.has(stmt.label)) {\n                    throw new ASTError(stmt.declLine, `label \"${stmt.label}\" is already declared`);\n                }\n                db.extFrames.set(stmt.label, {\n                    context: cloneFrameContext(currCtx),\n                    assertionLabel: stmt.label,\n                    assertionLine: stmt.declLine,\n                    assertionTypecode: stmt.typecode,\n                    assertionSymbols: stmt.symbols,\n                    mandatoryDvr: currCtx.dvr.extract(stmt.symbols),\n                    mandatoryHyps: filterMandatoryHyps(currCtx.hyps, db, currCtx.logiHyps, stmt.symbols),\n                    proofLabels: stmt.proofLabels,\n                    proofCompressed: stmt.proofCompressed === null ? null : parseCompressedProof(stmt.proofCompressed, stmt.declLine),\n                });\n            }\n            else if (ent.entryTy === parser_1.EntryType.Block) {\n                procBlock(ent.block, false, currCtx);\n            }\n            else {\n                console.log(\"Not implemented\", ent);\n                throw new Error(\"Not implemented: \" + ent.entryTy);\n            }\n        }\n    }\n    procBlock(outermostBlock, true, {\n        dvr: new DVRestriction(),\n        hyps: [],\n        logiHyps: [],\n    });\n    return db;\n}\nexports.createMMDB = createMMDB;\n\n\n//# sourceURL=webpack://metamath-pickaxe/./src/analyzer.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst parser_1 = __webpack_require__(/*! ./parser */ \"./src/parser.ts\");\nconst analyzer_1 = __webpack_require__(/*! ./analyzer */ \"./src/analyzer.ts\");\nconst verifier_1 = __webpack_require__(/*! ./verifier */ \"./src/verifier.ts\");\nlet codeMirror = CodeMirror(document.body, {\n    lineNumbers: true,\n});\n//\"demo0.mm\"\n//\"set.mm\"\n//\"iset.mm\"\n//\"hol.mm\"\n//\"miu.mm\"\n//\"nf.mm\"\n//\"peano.mm\"\n//\"ql.mm\"\n//\"big-unifier.mm\"\nfetch(\"https://raw.githubusercontent.com/metamath/set.mm/master/hol.mm\")\n    .then((response) => response.text())\n    .then((text) => {\n    //        codeMirror.setValue(text);\n    const ast = (0, parser_1.parseMM)(text);\n    const db = (0, analyzer_1.createMMDB)(ast);\n    let numCheckedProof = 0;\n    let numVerifiedProof = 0;\n    for (const [label, frame] of db.extFrames.entries()) {\n        if (!frame.proofLabels) {\n            continue;\n        }\n        numCheckedProof++;\n        console.log(frame.assertionLabel);\n        const verifResult = (0, verifier_1.verifyProof)(db, frame);\n        if (verifResult === true) {\n            numVerifiedProof++;\n        }\n        else {\n            console.log(\"verification failed\", verifResult);\n        }\n        console.log(\"verification result\", numVerifiedProof, \"/\", numCheckedProof);\n    }\n});\n\n\n//# sourceURL=webpack://metamath-pickaxe/./src/main.ts?");

/***/ }),

/***/ "./src/parser.ts":
/*!***********************!*\
  !*** ./src/parser.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseMM = exports.EntryType = exports.ParseError = void 0;\nfunction tokenize(text) {\n    const lines = text.split(/\\r?\\n/);\n    const tokens = [];\n    let lineIx = 1;\n    for (const line of lines) {\n        for (const preToken of line.split(/\\s+/)) {\n            if (preToken.length > 0) {\n                tokens.push({ text: preToken, line: lineIx });\n            }\n        }\n        lineIx += 1;\n    }\n    return tokens;\n}\nfunction removeOptionals(tokens) {\n    let State;\n    (function (State) {\n        State[State[\"Normal\"] = 0] = \"Normal\";\n        State[State[\"Comment\"] = 1] = \"Comment\";\n    })(State || (State = {}));\n    const result = [];\n    let state = State.Normal;\n    for (const token of tokens) {\n        if (state === State.Normal) {\n            if (token.text === \"$(\") {\n                state = State.Comment;\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (state === State.Comment) {\n            if (token.text === \"$)\") {\n                state = State.Normal;\n            }\n        }\n    }\n    return result;\n}\n// Input data error at tokenizer/parser level.\nclass ParseError {\n    constructor(line, message) {\n        this.line = line;\n        this.message = message;\n    }\n}\nexports.ParseError = ParseError;\nvar EntryType;\n(function (EntryType) {\n    // statement\n    EntryType[EntryType[\"CS\"] = 0] = \"CS\";\n    EntryType[EntryType[\"VS\"] = 1] = \"VS\";\n    EntryType[EntryType[\"AS\"] = 2] = \"AS\";\n    EntryType[EntryType[\"PS\"] = 3] = \"PS\";\n    EntryType[EntryType[\"DS\"] = 4] = \"DS\";\n    EntryType[EntryType[\"FS\"] = 5] = \"FS\";\n    EntryType[EntryType[\"ES\"] = 6] = \"ES\";\n    // block\n    EntryType[EntryType[\"Block\"] = 7] = \"Block\";\n})(EntryType = exports.EntryType || (exports.EntryType = {}));\nfunction parseSymbol(revTokens) {\n    const tok = revTokens.pop();\n    if (!tok || tok.text.startsWith(\"$\")) {\n        throw new ParseError(tok.line, `Unexpected token ${tok === null || tok === void 0 ? void 0 : tok.text}, expected symbol`);\n    }\n    return tok.text;\n}\nfunction parseLabel(revTokens) {\n    const tok = revTokens.pop();\n    if (!tok || !/^[-._A-Za-z0-9]+$/.test(tok.text)) {\n        throw new ParseError(tok.line, `Expected label, found ${tok.text}`);\n    }\n    return tok.text;\n}\nfunction parseCompressedProofFragment(revTokens) {\n    const tok = revTokens.pop();\n    if (!tok || !/^[A-Z]+$/.test(tok.text)) {\n        throw new ParseError(tok.line, `Expected compressed proof, found \"${tok.text}\"`);\n    }\n    return tok.text;\n}\nfunction parseCStmt(revTokens) {\n    const token = revTokens.pop();\n    const stmt = {\n        symbols: [],\n        declLine: token.line,\n    };\n    while (true) {\n        const token = revTokens[revTokens.length - 1];\n        if (token.text === \"$.\") {\n            revTokens.pop();\n            break;\n        }\n        else {\n            stmt.symbols.push(parseSymbol(revTokens));\n        }\n    }\n    return stmt;\n}\nfunction parseVStmt(revTokens) {\n    const token = revTokens.pop();\n    const stmt = {\n        symbols: [],\n        declLine: token.line,\n    };\n    while (true) {\n        const token = revTokens[revTokens.length - 1];\n        if (token.text === \"$.\") {\n            revTokens.pop();\n            break;\n        }\n        else {\n            stmt.symbols.push(parseSymbol(revTokens));\n        }\n    }\n    return stmt;\n}\nfunction parseDStmt(revTokens) {\n    const token = revTokens.pop();\n    const stmt = {\n        symbols: [],\n        declLine: token.line,\n    };\n    while (true) {\n        const token = revTokens[revTokens.length - 1];\n        if (token.text === \"$.\") {\n            revTokens.pop();\n            break;\n        }\n        else {\n            stmt.symbols.push(parseSymbol(revTokens));\n        }\n    }\n    return stmt;\n}\nfunction parseFStmt(revTokens) {\n    const tokLabel = revTokens.pop();\n    revTokens.pop(); // $f\n    const tokTypecode = revTokens.pop();\n    const tokVar = revTokens.pop();\n    const tokEnd = revTokens.pop();\n    if ((tokEnd === null || tokEnd === void 0 ? void 0 : tokEnd.text) !== \"$.\") {\n        throw new ParseError(tokLabel.line, \"$. expected\");\n    }\n    if (!tokVar) {\n        throw new ParseError(tokLabel.line, \"Unexpected end of file in $v\");\n    }\n    return {\n        label: tokLabel.text,\n        typecode: tokTypecode.text,\n        symbol: tokVar.text,\n        declLine: tokLabel.line,\n    };\n}\nfunction parseAStmt(revTokens) {\n    const tokLabel = revTokens.pop();\n    revTokens.pop(); // $a\n    const tokTypecode = revTokens.pop();\n    const stmt = {\n        label: tokLabel.text,\n        typecode: tokTypecode.text,\n        symbols: [],\n        declLine: tokLabel.line,\n    };\n    while (true) {\n        const token = revTokens[revTokens.length - 1];\n        if (token.text === \"$.\") {\n            revTokens.pop();\n            break;\n        }\n        else {\n            stmt.symbols.push(parseSymbol(revTokens));\n        }\n    }\n    return stmt;\n}\nfunction parseEStmt(revTokens) {\n    const tokLabel = revTokens.pop();\n    revTokens.pop(); // $e\n    const tokTypecode = revTokens.pop();\n    const stmt = {\n        label: tokLabel.text,\n        typecode: tokTypecode.text,\n        symbols: [],\n        declLine: tokLabel.line,\n    };\n    while (true) {\n        const token = revTokens[revTokens.length - 1];\n        if (token.text === \"$.\") {\n            revTokens.pop();\n            break;\n        }\n        else {\n            stmt.symbols.push(parseSymbol(revTokens));\n        }\n    }\n    return stmt;\n}\nfunction parsePStmt(revTokens) {\n    const tokLabel = revTokens.pop();\n    revTokens.pop(); // $p\n    const tokTypecode = revTokens.pop();\n    const stmt = {\n        label: tokLabel.text,\n        typecode: tokTypecode.text,\n        symbols: [],\n        proofLabels: [],\n        proofCompressed: null,\n        declLine: tokLabel.line,\n    };\n    while (true) {\n        const token = revTokens[revTokens.length - 1];\n        if (token.text === \"$=\") {\n            revTokens.pop();\n            break;\n        }\n        else {\n            stmt.symbols.push(parseSymbol(revTokens));\n        }\n    }\n    // TODO: $= ? $.case\n    const token = revTokens[revTokens.length - 1];\n    if (token.text === \"(\") {\n        // compressed proof\n        revTokens.pop();\n        while (true) {\n            const token = revTokens[revTokens.length - 1];\n            if (token.text === \")\") {\n                revTokens.pop();\n                break;\n            }\n            else {\n                stmt.proofLabels.push(parseLabel(revTokens));\n            }\n        }\n        let compressedProof = \"\";\n        while (true) {\n            const token = revTokens[revTokens.length - 1];\n            if (token.text === \"$.\") {\n                revTokens.pop();\n                break;\n            }\n            else {\n                compressedProof += parseCompressedProofFragment(revTokens);\n            }\n        }\n        stmt.proofCompressed = compressedProof;\n    }\n    else {\n        // non-compressed proof\n        while (true) {\n            const token = revTokens[revTokens.length - 1];\n            if (token.text === \"$.\") {\n                revTokens.pop();\n                break;\n            }\n            else {\n                stmt.proofLabels.push(parseLabel(revTokens));\n            }\n        }\n    }\n    return stmt;\n}\nfunction parseNestedBlock(revTokens) {\n    const tokBegin = revTokens.pop(); // ${\n    const block = {\n        entries: [],\n        beginLine: tokBegin.line,\n        endLine: tokBegin.line\n    };\n    while (true) {\n        const tok = revTokens[revTokens.length - 1];\n        if (tok.text === \"$}\") {\n            revTokens.pop();\n            block.endLine = tok.line;\n            break;\n        }\n        else {\n            block.entries.push(parseEntry(revTokens));\n        }\n    }\n    return block;\n}\nfunction parseEntry(revTokens) {\n    const tok = revTokens[revTokens.length - 1];\n    if (tok.text === \"$c\") {\n        return {\n            entryTy: EntryType.CS,\n            stmt: parseCStmt(revTokens),\n            block: null,\n        };\n    }\n    else if (tok.text === \"$v\") {\n        return {\n            entryTy: EntryType.VS,\n            stmt: parseVStmt(revTokens),\n            block: null,\n        };\n    }\n    else if (tok.text === \"$d\") {\n        return {\n            entryTy: EntryType.DS,\n            stmt: parseDStmt(revTokens),\n            block: null,\n        };\n    }\n    else if (tok.text === \"${\") {\n        return {\n            entryTy: EntryType.Block,\n            stmt: null,\n            block: parseNestedBlock(revTokens),\n        };\n    }\n    else if (tok.text.startsWith(\"$\")) {\n        throw new ParseError(tok.line, \"Unknown statement: \" + tok.text);\n    }\n    else {\n        const nextTok = revTokens[revTokens.length - 2];\n        if (!nextTok) {\n            throw new ParseError(tok.line, \"Unexpected end of file after label\");\n        }\n        if (nextTok.text === \"$f\") {\n            return {\n                entryTy: EntryType.FS,\n                stmt: parseFStmt(revTokens),\n                block: null,\n            };\n        }\n        else if (nextTok.text === \"$a\") {\n            return {\n                entryTy: EntryType.AS,\n                stmt: parseAStmt(revTokens),\n                block: null,\n            };\n        }\n        else if (nextTok.text === \"$e\") {\n            return {\n                entryTy: EntryType.ES,\n                stmt: parseEStmt(revTokens),\n                block: null,\n            };\n        }\n        else if (nextTok.text === \"$p\") {\n            return {\n                entryTy: EntryType.PS,\n                stmt: parsePStmt(revTokens),\n                block: null,\n            };\n        }\n        else {\n            throw new ParseError(tok.line, `Unknown statement \"${nextTok.text}\" (with label \"${tok.text}\")`);\n        }\n    }\n}\n// can throw ParseError\nfunction parseMM(text) {\n    var _a, _b, _c;\n    const eofHack = \"$end of file$\"; // cannot appear as normal token, because this string contains whitespaces\n    const tokens = removeOptionals(tokenize(text));\n    const revTokens = Array.from(tokens);\n    revTokens.push({ text: eofHack, line: ((_a = tokens[tokens.length - 1]) === null || _a === void 0 ? void 0 : _a.line) || 1 });\n    revTokens.reverse();\n    const entries = [];\n    while (revTokens.length > 0 && revTokens[revTokens.length - 1].text !== eofHack) {\n        entries.push(parseEntry(revTokens));\n    }\n    return {\n        entries: entries,\n        beginLine: ((_b = tokens[0]) === null || _b === void 0 ? void 0 : _b.line) || 1,\n        endLine: ((_c = tokens[tokens.length - 1]) === null || _c === void 0 ? void 0 : _c.line) || 1,\n    };\n}\nexports.parseMM = parseMM;\n\n\n//# sourceURL=webpack://metamath-pickaxe/./src/parser.ts?");

/***/ }),

/***/ "./src/verifier.ts":
/*!*************************!*\
  !*** ./src/verifier.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyProof = void 0;\nvar ProofStackOpType;\n(function (ProofStackOpType) {\n    ProofStackOpType[ProofStackOpType[\"Push\"] = 0] = \"Push\";\n    ProofStackOpType[ProofStackOpType[\"Store\"] = 1] = \"Store\";\n    ProofStackOpType[ProofStackOpType[\"Load\"] = 2] = \"Load\";\n})(ProofStackOpType || (ProofStackOpType = {}));\n;\nfunction decodeNormalProof(labels) {\n    const result = [];\n    for (const label of labels) {\n        result.push({\n            ty: ProofStackOpType.Push,\n            pushLabel: label,\n            memoryIx: undefined,\n        });\n    }\n    return result;\n}\nfunction decodeCompressedProof(compressedProof, mandatoryHypLabels, optionalLabels) {\n    const result = [];\n    let memoryIx = 0;\n    for (const rawOp of compressedProof) {\n        if (rawOp === \"Z\") {\n            result.push({\n                ty: ProofStackOpType.Store,\n                pushLabel: undefined,\n                memoryIx: memoryIx,\n            });\n            memoryIx++;\n        }\n        else {\n            const num = rawOp;\n            if (num < mandatoryHypLabels.length) {\n                result.push({\n                    ty: ProofStackOpType.Push,\n                    pushLabel: mandatoryHypLabels[num],\n                    memoryIx: undefined,\n                });\n            }\n            else if (num < mandatoryHypLabels.length + optionalLabels.length) {\n                result.push({\n                    ty: ProofStackOpType.Push,\n                    pushLabel: optionalLabels[num - mandatoryHypLabels.length],\n                    memoryIx: undefined,\n                });\n            }\n            else {\n                const loadIx = num - mandatoryHypLabels.length - optionalLabels.length;\n                if (loadIx >= memoryIx) {\n                    throw new Error(\"Invalid compressed proof (referencing undefined subproof)\");\n                }\n                result.push({\n                    ty: ProofStackOpType.Load,\n                    pushLabel: undefined,\n                    memoryIx: loadIx,\n                });\n            }\n        }\n    }\n    return result;\n}\nfunction symSeqEqual(symSeqA, symSeqB) {\n    if (symSeqA.length !== symSeqB.length) {\n        return false;\n    }\n    for (let i = 0; i < symSeqA.length; i++) {\n        if (symSeqA[i] !== symSeqB[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n// Very simple unifier that only processes contraints from front-to-back, in greedy matching. (no backtracking)\n// Metamath proof semantics is designed such that this kind of unifier always works.\nclass SimpleUnifier {\n    // vars are target of unification. All other symbols are considered constants.\n    constructor(vars) {\n        this.unifier = new Map(); // key: variable, value: symbol sequence (value can be empty seq)\n        this.vars = vars;\n    }\n    // Constrain this unification to satisfy: this.apply(from) === to\n    addConstraint(from, to) {\n        for (const fromSym of from) {\n            // const case\n            if (!this.vars.has(fromSym)) {\n                if (to.length === 0) {\n                    return `could not match symbol \"${fromSym}\" (const) to empty sequence`;\n                }\n                if (to[0] !== fromSym) {\n                    return `could not match symbol \"${fromSym}\" (const) to \"${to[0]}\" (const)`;\n                }\n                // ok\n                to = to.slice(1);\n                continue;\n            }\n            // var case (already unified)\n            const unif = this.unifier.get(fromSym);\n            if (unif !== undefined) {\n                if (!symSeqEqual(unif, to.slice(0, unif.length))) {\n                    return `for\" ${fromSym}\" (var), contradictinon found 1. ${unif} 2. ${to.slice(0, unif.length)}`;\n                }\n                // ok\n                to = to.slice(unif.length);\n                continue;\n            }\n            // var case (not unified yet) : greedy match\n            this.unifier.set(fromSym, to);\n            to = [];\n        }\n        if (to.length > 0) {\n            return `could not match empty sequence to \"${to}\"`;\n        }\n        return true;\n    }\n    // Replaces each variable in symSeq to symbol sequences, that satisfies all previous addConstraint() calls.\n    apply(symSeq) {\n        const result = [];\n        for (const sym of symSeq) {\n            if (this.vars.has(sym)) {\n                const u = this.unifier.get(sym);\n                if (u === undefined) {\n                    throw new Error(`Unification failed for ${sym}. Probably caller's bug.`);\n                }\n                result.push(...u);\n            }\n            else {\n                result.push(sym);\n            }\n        }\n        return result;\n    }\n    applyToDvr(dvr) {\n        const unifierVarOnly = new Map();\n        for (const [k, syms] of this.unifier) {\n            unifierVarOnly.set(k, syms.filter((sym) => this.vars.has(sym)));\n        }\n        return dvr.substituteMultiple(unifierVarOnly);\n    }\n}\n// Returns true is the proof is valid, otherwise failure reason string.\nfunction verifyProof(db, frame) {\n    if (!frame.proofLabels) {\n        throw new Error(\"frame must contain a proof\");\n    }\n    let decodedOps = [];\n    if (!frame.proofCompressed) {\n        decodedOps = decodeNormalProof(frame.proofLabels);\n    }\n    else {\n        decodedOps = decodeCompressedProof(frame.proofCompressed, frame.mandatoryHyps.map((h) => h.label), frame.proofLabels);\n    }\n    const memory = new Map();\n    const stack = [];\n    for (const op of decodedOps) {\n        if (op.ty === ProofStackOpType.Store) {\n            memory.set(op.memoryIx, stack[stack.length - 1]);\n            continue;\n        }\n        if (op.ty === ProofStackOpType.Load) {\n            stack.push(memory.get(op.memoryIx));\n            continue;\n        }\n        const label = op.pushLabel;\n        var hyp = frame.context.hyps.filter((h) => h.label === label)[0];\n        if (hyp) {\n            stack.push([hyp.typecode, ...hyp.symbols]);\n            continue;\n        }\n        const assertion = db.extFrames.get(label);\n        if (assertion) {\n            const arity = assertion.mandatoryHyps.length;\n            if (stack.length < arity) {\n                return `Assertion \"${assertion.assertionLabel}\" requires ${arity} arguments, but only ${stack.length} arguments are available in proof stack.`;\n            }\n            const args = stack.splice(-arity, arity);\n            const unifier = new SimpleUnifier(db.varSymbols);\n            for (let i = 0; i < arity; i++) {\n                const hyp = assertion.mandatoryHyps[i];\n                const res = unifier.addConstraint([hyp.typecode, ...hyp.symbols], args[i]);\n                if (res !== true) {\n                    return `Unification failed: ${res}`;\n                }\n            }\n            if (!unifier.applyToDvr(assertion.mandatoryDvr).satisfiedBy(frame.context.dvr)) {\n                return `Disjointness requirement of referenced assertion ${assertion.assertionLabel} is not satisfied by proof context`;\n            }\n            stack.push(unifier.apply([assertion.assertionTypecode, ...assertion.assertionSymbols]));\n            continue;\n        }\n        throw new Error(`Invalid frame, missing ${label}`); // analyzer should prevent this from happening.\n    }\n    if (stack.length !== 1) {\n        return `Excess or missing proof steps; stack size is ${stack.length} (must be 1)`;\n    }\n    if (!symSeqEqual(stack[0], [frame.assertionTypecode, ...frame.assertionSymbols])) {\n        return `Proven symbol sequence \"${stack[0]}\" does not match assertion \"${frame.assertionSymbols}\"`;\n    }\n    return true;\n}\nexports.verifyProof = verifyProof;\n\n\n//# sourceURL=webpack://metamath-pickaxe/./src/verifier.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;